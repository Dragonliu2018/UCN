# 第2章 数据的机器级表示与处理

![&#x8DEF;&#x7EBF;&#x56FE;](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-24_09-25-22.jpg)

## 数据表示基础

### **0x01 进制转化**

1. **出题**：$$\frac{2010}{128} 转二进制或十六进制$$ ：2010用到快速转换\(2048 - 38 = 2047 - 37\)得到0111 1101 1010，再除以一个128\( $$2^7$$ \)是小数点向左移动7位得 0111 1.101 1010，转十六进制注意补零得F.B4。
2. R进制转十进制：按权展开
3. 十进制转R进制：整数部分\(除基取余，上右下左\)、小数部分\(乘基取整，上左下右\)
4. 二、八、十六进制相互转化：每三位、四位一转，整数部分从低位到高位，小数部分从高位到低位，注意补0
5. **快速转换\(记住常见的2的幂次\)：** $$2^5= 32，2^6 = 64，2^7 = 128，2^8 = 256，2^9= 512，2^{10} = 1024(KB)，2^{11} = 2048，2^{12} = 4096，2^{13}= 8192，2^{14} = 16384，2^{15} = 32768，2^{16} = 65536，2^{20}= 1048576(MB)，2^{30} = 1073741824(GB)，2^{40} = 1TB$$
6. 分数转化：注意分母是否是2的幂次 

### 0x02 **虚拟存储器和虚拟地址空间**

1. **虚拟存储器：**为了方便存储管理而提出的概念上的存储器，不能等同于物理内存
2. **虚拟地址空间：**存储器为每个字节都编写一个唯一的地址，所有可能的地址集合，被称为虚拟地址空间。**字长\(用来指明整数和指针的标称大小\)**决定虚拟地址空间的大小。
3. 区别：字表示被处理信息的单位，用来度量数据类型的宽度。

### 0x03 **字与字节**

1. 字长用来指明整数和指针的标称大小；数据通路的宽度。
2. 数据通路指CPU内部数据流经的路径以及路径上的部件，主要是CPU内部进行数据运算、存储和传送的部件，这些部件的宽度基本上要一致，才能相互匹配。因此，”字长”等于CPU内部总线的宽度、运算器的位数、通用寄存器的宽度等。
3. 字表示被处理信息的单位，用来度量数据类型的宽度。
4. 字与字长可以相同，也可不同。

### 0x04 **大端小端表示\(测试\)**

1. **小端法：LSB排在最小的地址处（与习惯反着）**
2. **大端法：MSB排在最小的地址处（与习惯相同）**
3. **按字节存储，一字节是8位\(十六进制的2位\)**
4. **指令：操作码-&gt;寄存器编号-&gt;立即数。只有立即数考虑字节顺序。**

## 数值型数据表示与处理

### **0x01 整数\(定点数\)补码**

#### 1. 补码定义

　　假设补码有n位，则 $$[X]_补 = 2^n + X( -2^n\leq X < 2^n, mod 2^n)$$ X是真值， $$[X]_补$$ 是机器数。负权表示： $$X = -2^{w-1} + \sum_{i=0}^{w-2}x_i2^i$$ 

#### 2. 转化\(重点\)

1. 真值转补码：一个负数的补码等于对应正数补码按位取反、末位加1（简便方法：从右到左遇到第一个1前面各位取反）
2. 补码转真值：符号为0，则为正数，数值部分相同；符号为1，则为负数，数值各位取反，末位加1.

#### 3. 补码表示带符号数的优势\(重点\)

1. 补码运算是模运算系统，加、减统一
2. 数0的表示唯一，方便使用
3. 比原码或反码多表示一个最小负数

#### 4. 注意

1. 补码最小值不对称，n位机器码的最小负数 $$1 00..00 (n-1个0)$$ 
2. 运算器可看作模为 $$2^n$$ 的模运算系统

### 0x02 浮点数的编码表示

#### 1. IEEE754编码原理及过程，理解其引入非规格化数的原因

| type | S\(符号\) | exp\(阶码\) | frac\(尾数\) |
| :---: | :---: | :---: | :---: |
| float | 1bit | 8bits | 23bits |
| double | 1bit | 11bits | 52bits |

![float&#x7C7B;&#x578B;](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-26_21-38-23.jpg)

![&#x6D6E;&#x70B9;&#x6570;&#x5BC6;&#x5EA6;&#x53CA;&#x5206;&#x5E03;](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-26_21-52-47.jpg)



#### **2.** 真值和机器数之间的转换

* 真值转编码：将真值转为二进制科学计数法，填写**Sign**\(单1双1，正0负1\)，指数+Bias\(单127双1023\)填写**exp**\(单8双11\)，**frac**照搬小数部分\(单23双52，末尾补0\)
* 编码转真值：**sign**判断正负，**exp**-Bias得指数，**frac**根据exp转成二进制小数再转化\(frac转成十进制小数再乘以exp\)

#### 3. 给定格式浮点数表示的范围和精度

#### 4. float、double和int的精度比较

* double最高
* $$10^{24}$$ 之前float比int高，之后低

#### 5. 浮点数表示中谁决定了精度？谁决定了范围？

* 阶码对应范围，尾数对应精度

#### 6. float注意

* 当数据是一个不可表示数时，机器会将其转换为最邻近的可表示数
* 大数吃小数：加法结合律不一定正确
* 判断两个实数是否相等，须用这两个实数相减取绝对值，再判断该绝对值是否小于一定的精度

#### 7. 解决C程序中与浮点数表示范围和精度相关的问题

#### 8. 上溢下溢：

　　当实数值超出浮点数能表示的最大范围，也就是发生上溢时，运行结果为无穷，下溢时，就近舍入0或者最小的非规格化数。NaN用于提示不合理操作

## 非数值型数据表示

## 整数的运算实现

### 0x01 移位

* 右移：**&gt;&gt;**，右移n位相当于除以 $$2^n$$ 
* 左移**：&lt;&lt;，**左移n位相当于乘以 $$2^n$$ 
* 无符号数：逻辑左移、逻辑右移
  *  逻辑左移：高位移出，低位补0，可能溢出；
  *  逻辑右移：低位移出，高位补0，可能产生有效数据丢失；
  *  溢出判断：若高位移出的是1，则左移时发生溢出
* 有符号整数：算术左移、算术右移
  *  算术左移：高位移出，低位补0，可能溢出
  *  算术右移：低位移出，高位补符，可能产生有效数据丢失；
  *  溢出判断：若移出的位不等于新的符号位，则溢出

### 0x02 位扩展和位截断

* 带符号数位扩展：前面补符号位 ，符号扩展
* 不带符号数扩展：前面补0 ，0扩展
* 与本身有关，与目标类型无关
* 高位截断

### 0x03 注意

* 不能遇到小数就用浮点数表示，有些情况（如将一个整数变量乘以一个确定的小数常量），可先用一个确定的定点整数与整数变量相乘，然后再通过移位运算来确定小数点。

### 0x04 补码

* 定义： $$[X]_补 = 2^n + X( -2^n\leq X < 2^n, mod 2^n)$$
* 性质：一个负数的补码等于模减该负数的绝对值
* $$[x+y]_补=2^n+x+y=2^n+x+2^n+y=[x]_补+[y]_补,(mod 2^n)$$ 
* $$[x-y]_补=2^n+x-y=2^n+x+2^n-y=[x]_补+[-y]_补,(mod 2^n)$$ 
* 实现减法的主要工作在于求 $$[-B]_补 = [\overline B]_补+1$$ 

### 0x04 带标志加法器的构成及原理

#### 注意

* 计算机中所有得运算都是基于加法器实现；
* 加法器不知道要运算的是带符号数还是无符号数
* 加法器不判对错，总是取低n位作为结果，并生成标志信息

![&#x5E26;&#x6807;&#x5FD7;&#x4F4D;&#x7684;&#x52A0;&#x6CD5;&#x5668;](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-26_23-17-32.jpg)

* $$A和B'$$ ：加法器输入端
* ALU通常仅用于进行加减以及各类逻辑运算和传送操作，乘除法只能利用ALU分步骤进行多次加减和移位间接完成

### 0x05 标志位的计算

* 溢出标志OF：$$OF=C_n⊕C_{n-1}$$
* 符号标志SF： $$SF=F_{n-1}$$ 
* 零标志ZF=1当且仅当F=0
* 进位/借位标志CF： $$CF=cin⊕cout$$ 

### 0x06 判别整数加/减运算是否溢出

* 机器级语言可直接通过标志位判断，有符号溢出 $$OF=1$$ ，无符号 $$CF=1$$ 
* 有符号数溢出检测标志 $$OF=C_n⊕C_{n-1}=1$$或 正正得负\(正溢出\)、负负得正\(负溢出\) 和的符号位与加数的不同
* 无符号减溢出：差为负数，即借位CF=1；加溢出：和数小于加数；当最高为向更高位有进位（或借位）时产生溢出
* 高级语言通过程序进行溢出判断
  * 无符号相减溢出：小数-大数；相减的结果大于被减数
  * 负 - 正 = 正，正 - 负 = 负

![&#x65E0;&#x7B26;&#x53F7;&#x6570;](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-26_23-46-46.jpg)

![&#x5E26;&#x7B26;&#x53F7;&#x6570;](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-26_23-47-58.jpg)

```c
int uadd_ok(unsigned x, unsigned y)
{
	//判断无符号数加法是否溢出
	unsigned sum = x+y;
	return sum >= x; 
}//uadd_ok
int usub_ok(unsigned x, unsigned y)
{
	//判断无符号数减法是否溢出
	//法1
	return x >= y; 
	//法2
	int sub = x-y;
	return sub<=x;//差<=被减数
}//usub_ok
int tadd_ok(int x, int y)
{
	//判断带符号数加法是否溢出
	int sum = x+y;
	int neg_over = x<0 && y<0 && sum>=0;//负负得正
	int pos_over = x>=0 && y>=0 && sum<0;//正正得负
	return !neg_over && !pos_over; 
}//tadd_ok
int tsub_ok(int x, int y)
{
	//判断带符号数减法是否溢出
	if( x==0 && y==0x80000000 )//x-y=2^31
		return 0;
	else
		return tadd_ok(x, -y);
}//tsub_ok 
```

### 0x07 怎样比较两个整数的大小

* 做**减法**以比较大小，规则：
* unsigned：CF=0，大于：做减法未产生借位，在ZF=0的限定下则前者大于等于后者
* signed：OF = SF，大于：**\(当ZF = 0的限定下\)**
  * SF=OF表示大于的两种情况
    * SF = 0，OF = 0：表示 a - b &gt; 0 并且结果没有溢出，即 a &gt; b
    * SF = 1，OF = 1：a - b 可表示成 $$a + [-b]_补$$ ，而由OF = 1 可得结果溢出，即表示 a 与 $$[-b]_补$$ 同号但与结果异号，又SF = 1，所以 a 与 $$[-b]_补$$ 的符号位为 0 ；即在SF = OF = 1的情况下，a必为正或0，而b必为负或0，a &gt; b 成立
  * SF != OF的情况
    * SF = 1， OF = 0：表示 a - b &lt; 0 并且结果没有溢出，即 a &lt; b
    * SF = 0， OF = 1：a - b 可表示成 $$a + [-b]_补$$ ，而由OF = 1 可得结果溢出，即表示 a 与 $$[-b]_补$$ 同号但与结果异号，又SF = 0，所以 a 与 $$[-b]_补$$ 的符号位为 1 ；即在 SF = 0 且 OF = 1 的情况下，a必为负或0，而b必为正或0，a &lt; b 成立

### 0x08 整数的乘除运算

#### 01. 注意

1. 无符号乘和有符号乘的低n位结果一样，最后结果也只保留低n位，但使用两类指令、两套电路。原因：两者判定溢出的方式不同。\(加减法在i32上不分，MIPS上分\)
2. 不管是有符号数还是无符号数的乘法，即使乘积溢出时，用移位和加减运算组合的方式得到的结果都是和采用直接相乘的结果是一样的

#### 02. 有符号乘数运算\(布斯运算\)

* 步骤：先改造乘数，然后再做二进制乘法运算
* 乘数改造：末尾添0，后一位减前一位

#### 03. 判溢出\(z = x \* y\)

* **低级语言**
  * **signed**：当 $$-2^{n-1}\leq x*y <2^{n-1}$$ \(不溢出\)时，即乘积的高n位为全1或全0并等于低n位的最高位时不溢出；乘积的高n位不为全1或全0时溢出
  * unsigned：乘积的高n位不为全0时溢出
* **高级语言：** $$!x||\frac{z}{x}=y$$ 为真时溢出

#### 04. 变量与常数之间的乘运算

* 编译器在处理变量与常数相乘时，往往以移位、加法和减法的组合运算来代替乘法运算
* 原因：整数乘法运算比移位和加法等运算所用时间长
* 不能整除时，采用朝零舍入，即截断方式
  * 无符号数：直接截断
  * 有符号数：先纠偏，再右移

![](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-27_13-36-13.jpg)

#### 05. 整数乘运算实现原理：加法和移位

#### 06. 整数除运算溢出问题

　　整数除法不会很难发生溢出，除了 ![-2^{n-1} / -1](https://math.jianshu.com/math?formula=-2%5E%7Bn-1%7D%20%2F%20-1)，会发生溢出外，其余的情况都不会溢出。因为**负数的个数**比**正数的个数**多了一个。而且 x 除 0 的结果无法用机器数字表示，但是浮点数就不一样了，浮点数能够用机器数表示无穷

#### 07. 用移位实现整型变量除2的幂次：负整数纠偏

#### 08. 尝试仅用位运算实现算术运算函数

## 浮点数的运算实现

### 0x01 浮点数加减过程

![](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-27_13-41-43.jpg)

### 0x02浮点数加减运算过程（乘除运算不用对阶，其余步骤类似）

## 问题讨论

### 0x01 C程序中的整数

#### 1. 数据类型表示范围\(64位机器\)（重点）

| 类型名称 | 字节数 | 取值范围 |
| :---: | :---: | :---: |
| \(signed\) char | 1 | $$ -2^7(-128) $$ ~ $$2^7-1(127)$$  |
| usigned char | 1 | 0 ~ $$2^8-1(255)$$  |
| short \(int\) | 2 | $$-2^{15}(-32 768) $$ ~ $$2^{15}-1(32 767)$$  |
| usigned short | 2 | 0 ~ $$2^{16}-1(65 535)$$  |
| int | 4 | $$-2^{31}(-2 147 483 648)$$ ~ $$2^{31}-1(2 147 483 647)$$  |
| usigned （int\) | 4 | 0 ~ $$2^{32}-1(4 294 967 295)$$  |
| long int  | 4 | $$-2^{31}(-2 147 483 648)$$ ~ $$2^{31}-1(2 147 483 647)$$  |
| usigned long | 4 | 0 ~ $$2^{32}-1(4 294 967 295)$$  |
| long long | 8 | $$-2^{63}(-9.2233720368548e+18)$$ ~ $$2^{63}-1(9.2233720368548e+18)$$  |
| usigned long long | 8 | 0 ~ $$2^{64}-1(1.844674407371e+19)$$  |

#### 2. 编译器约定（重点）

1. 若表达式中同时有无符号和带符号整数，则C编译器将带符号整数强制转换为无符号数。
2. 处理常量时默认的类型
3. -x会看成x，然后取负运算

![&#x56FE;1 C&#x8BED;&#x8A00;&#x5904;&#x7406;&#x5E38;&#x91CF;&#x65F6;&#x9ED8;&#x8BA4;&#x7684;&#x7C7B;&#x578B;](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_17-25-12.jpg)

### 0x02 牛刀小试（重点）

![&#x56FE;2](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_17-40-25.jpg)

![&#x56FE;3](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_17-44-21.jpg)

![&#x56FE;4](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_11-45-49.jpg)

![&#x56FE;5](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_11-52-55.jpg)

![&#x56FE;6](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_18-01-37.jpg)

### 0x03 问题讨论1（重点）

![&#x56FE;7](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_11-58-58.jpg)

1. 不永真， $$0x0fffffff$$ ，使其溢出且最高位为1
2. 不永真， $$0x80000000$$ ，模拟钟表回拨
3. 永真；当x位于0x80000000~0xffffffff时，x&lt;0；当x位于0x00000000~0x7fffffff时，-x位于0x80000001~0x00000000，满足 -x ≤ 0；
4. 不永真：0x80000000

### 0x04 问题讨论2（重点）

![&#x56FE;8](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-18_07-54-57.jpg)

1. 当str1 &lt; str2时，size\_t是unsigned int 类型，strlen\(str1\) - strlen\(str2\)结果仍然是无符号类型，所以当str1 &lt; str2时，差还大于0.
2. `return strlen(str1) >  strlen(str2)`

### 0x05 无符号数

* **问**：你觉得计算机中为什么要支持无符号数呢？只用带符号整数可以吗？因为无符号数和带符号整数对数据表示的差异性，所以经常会导致数据转换时出现错误。你觉得在使用无符号数时，应避免踩哪些坑呢？也可以说说你的疑问。
* 1. 扩大数据表示范围，因为在无符号数中，所有的位都用于直接表示该值的大小。
  2. 原则上可以，但是如果要表示的数据都是非负数，这时使用带符号数会造成符号位的浪费\(因为符号位只为0\)；
  3. 使用无符号数时应该避免与带符号数的直接运算。

### 0x06 偏置常数

* **问**：偏置常数的作用是什么？IEEE754为什么把偏置常数设为2的n-1次方-1？（n是阶码位数）如果设成2的n-1次方会怎样？
* 1. Bias作用：将浮点数的指数统一转换为正指数，避免正负指数在计算上带来的麻烦；
  2. 扩大浮点数取值范围。精度越大则取值范围越小，精度越小则取值范围越大。以32位单精度浮点数为例：用127，阶码的范围是0000 0001（-126）~1111 1110（127）；用128，阶码的范围会变成0000 0001 （-127）~1111 1110（126）；显然如果使用128作为偏置常数，能表示的最大的指数是126，使用127作为偏置常数，能表示的最大的指数是127。所以规定8位阶码的Bias为127，使得浮点数的取值范围更大。

### 0x07 位扩展

* **问：**不同长度的数据类型在进行算术运算的时候，要对短数据进行位扩展，为什么不能直接运算呢？这里，位扩展的作用是什么呢？能举出实例来说明吗？
* 1. 原因：直接运算可能出现符号位错位而导致运算异常的情况
  2. 作用：将数据转化为同一类型，以便“正确”运算
  3. 举例：short 类型的6\(0x0006\)经位扩展转为int类型的6\(0x0000 0006\)

### 0x08 浮点数的阶码可以用补码编码吗？

* **问**：阶码可以用补码编码吗？既然移码是为了避免负阶而加的偏置常数，那为什么不直接用补码来表示阶呢？虽然有正负阶，但是我们补码一样可以方便地进行加减乘除运算啊，为什么用移码而不用补码呢？
* 1. 补码属于无符号数原码，利于比较大小；
  2. 便于判断规格化的值、非规格化的值、特殊值；
  3. 移码可使非规格化值平滑转换到规格化值
  4. 机器0的表示
  5. IEEE754非规格化数

### 0x09 位扩展程序

```c
#include<stdio.h>
int main()
{
	unsigned int a = 1;
	unsigned short b = 1;
	char c = -1;//补码全1
	int d; 
	d = (a > c) ? 1:0;
	printf("%d\n", d); 
	d = (b > c) ? 1:0;//short与char转成int
	printf("%d\n", d);
	return 0;
}
```

* **位扩展**：**char&short --&gt; int --&gt; usigned --&gt; long\(?\) --&gt;double &lt;-- float**
* char，unsigned short类型都是转成int来比较 c: 0xffff ffff b: 0x0000 0001 这是两个int比较，c=-1, b=1

### 0x0a char is signed or unsigned?

 　　C标准规定为 Implementation Defined（由**实作环境**决定\)。例如：arm-linux-gcc 规定 char 为 unsigned char，vc 编译器、x86上的 gcc 规定 char 为 signed char。缺省情况下，编译器默认数据为signed类型，但是char类型除外。  
　　这样会带来一些麻烦：代码移植\(使用char的时候，前面最好加个unsigned或signed\)；做位扩展题的时候到底是看作带符号数还是不带符号数\(我用电脑和朋友用手机运行我们这节课的讨论题就出现两个结果\)？  
　　输出CHAR\_MIN \(在limits.h头文件中\)的值就知道自己环境默认的是有符号还是无符号。

### 0x0b 定点表示法

* **优点** 1. 精度：较对应的IEEE754标准表示的浮点数高；  2. 运算速度：相对较快；  3. 不需要增加计算机硬件 
* **缺点** 1. 定点表示总是具有相同的绝对误差，错误会累加；  2. 提供非常有限的范围，不能有效地表示非常大的数

### 0x0c 浮点数运算举例

![](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-26_22-05-500.jpg)

### 0x0d 对阶

* **问**：为什么浮点数加减运算时规定小阶向大阶对齐呢？这样做的好处是什么呢？
* **答**： 由于浮点表示的数多是规格化的，尾数左移会引起最高有效位的丢失，造成很大误差；而尾数右移虽引起最低有效位的丢失，但造成的误差较小，因此，对阶操作规定使尾数右移，尾数右移后使阶码作相应增加，其数值保持不变。很显然，一个增加后的阶码与另一个相等，所增加的阶码一定是小阶。因此在对阶时，总是使**小阶向大阶看齐**，即小阶的尾数向右移位\(相当于小数点左移\)，每右移一位，其阶码加1，直到两数的阶码相等为止，右移的位数等于阶差△E。

### 0x0e 整数除的溢出和异常举例

![](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-27_13-27-28.jpg)

### 0x0f 0.1的float型表示

```c
#include <stdio.h>

int main()
{
	union{ //法1 
		float x;
		unsigned u;
	}num={0.1};
	
	float y=0.1;//法2 
	int integer = *(unsigned int *)(&y);//法3
	int *ptr = (int*)&y;//法4
	printf("%#x\n", y);
	printf("%#x\n", num.u);
	printf("%#x\n", integer);
	printf("%#x\n", *ptr);
	return 0;
}
```

1. 《C primer plus》中关于%X的定义：使用十六进制数字0F的无符号十六进制整数（C primer plus第五版，p68）我的理解：%X要将值转换成\(unsigned\)int整数类型再来进行输出
2. 法1使用union使得变量x和u共享内存，即u的机器码与x的一样，所以可输出0.1正确的机器码 0x3dcccccd
3. 法2是实现从float类型转到\(unsigned\)int类型：float x\(0x3dcccccd\)先需要位扩展变成double类型，可得double x\(0x3fb99999a0000000\)，然后再转成\(unsigned\)int，位截断，丢弃高32位得\(unsigned\)int x \(0xa0000000\)。所以会输出 a0000000，显然不是0.1的机器码
4. 法3：利用指针指向float的机器码，问题关键在于不得使float或double直接转化为int。

### 0x10 float到double的位扩展

```c
#include<stdio.h> 
int main()
{	
	union  
	{	
		float x;
 		unsigned u;
	}num={6.66};
	double d1 = num.x;
	double d2 = 6.66;
 	printf("float          ：#%x\n", num.u);//float机器码 
 	printf("double         ：#%llx\n", d2);//double机器码 
 	printf("double(位扩展) ：#%llx\n", d1);
 	return 0;
}
```

* **float型符号位1位，阶码8位，尾数23位，double阶码11位，尾数52位，所以float扩展成double，应该取double的符号位1位+阶码11位+尾数23位，一共35位，但是考虑到有些情况有舍入，所以至少是34位。（float的精度只有23+1位尾数，所以扩展到double的时候尾数后面只能补0）**

### **0x11 "int"型 double**

![](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-30_18-51-31.jpg)

1. 非永真，eg：x = 0x7fffffff,  y = 1；设法让 \(x+y\) 溢出
2. 永真，浮点数不满足结合律，但是此处的double是由int转化的，不存在溢出和大数吃小数的情况\(对阶\)
3. 非永真，精度损失；
4. 非永真，eg：x = 1, y = 0

### 0x12 整数加减能用逆运算吗？

1. 有符号\(int\)：x = 0x7fffffff, y = 1;  sum = x + y = 0x80000000，x = sum - 1；不可
2. 无符号\(int\)：x = 0xffffffff,  y = 1;  sum = x + y = 0x00000000，x = sum - 1；不可

* 分析：在模 $$2^n$$ 系统中满足逆运算

### 0x13 关于double 类型0/0的结果问题

* **问**：0/0可以看出结果为非数，机器码是阶码位和符号位全为1，小数位第一位为1，为什么会出现这种结果？
* **答**：由IEEE754标准和C编译环境规定，并无实际运算意义。

### 0x14 布斯乘法是一个快速运算乘法的算法，它与补码运算有什么关联吗或是说内在原理是什么？

![](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-04-01_13-18-37.jpg)

引自维基百科：[我跳](https://zh.wikipedia.org/wiki/%E5%B8%83%E6%96%AF%E4%B9%98%E6%B3%95%E7%AE%97%E6%B3%95)

