# 第2章 数据的机器级表示与处理

![&#x8DEF;&#x7EBF;&#x56FE;](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-24_09-25-22.jpg)

## 数据表示基础

### **0x01 进制转化**

1. **出题**：$$\frac{2010}{128} 转二进制或十六进制$$ ：2010用到快速转换\(2048 - 38 = 2047 - 37\)得到0111 1101 1010，再除以一个128\( $$2^7$$ \)是小数点向左移动7位得 0111 1.101 1010，转十六进制注意补零得F.B4。
2. R进制转十进制：按权展开
3. 十进制转R进制：整数部分\(除基取余，上右下左\)、小数部分\(乘基取整，上左下右\)
4. 二、八、十六进制相互转化：每三位、四位一转，整数部分从低位到高位，小数部分从高位到低位，注意补0
5. **快速转换\(记住常见的2的幂次\)：** $$2^5= 32，2^6 = 64，2^7 = 128，2^8 = 256，2^9= 512，2^{10} = 1024(KB)，2^{11} = 2048，2^{12} = 4096，2^{13}= 8192，2^{14} = 16384，2^{15} = 32768，2^{16} = 65536，2^{20}= 1048576(MB)，2^{30} = 1073741824(GB)，2^{40} = 1TB$$
6. 分数转化：注意分母是否是2的幂次 

### 0x02 **虚拟存储器和虚拟地址空间**

1. **虚拟存储器：**为了方便存储管理而提出的概念上的存储器，不能等同于物理内存
2. **虚拟地址空间：**存储器为每个字节都编写一个唯一的地址，所有可能的地址集合，被称为虚拟地址空间。**字长\(用来指明整数和指针的标称大小\)**决定虚拟地址空间的大小。
3. 区别：字表示被处理信息的单位，用来度量数据类型的宽度。

### 0x03 **字与字节**

1. 字长用来指明整数和指针的标称大小；数据通路的宽度。
2. 数据通路指CPU内部数据流经的路径以及路径上的部件，主要是CPU内部进行数据运算、存储和传送的部件，这些部件的宽度基本上要一致，才能相互匹配。因此，”字长”等于CPU内部总线的宽度、运算器的位数、通用寄存器的宽度等。
3. 字表示被处理信息的单位，用来度量数据类型的宽度。
4. 字与字长可以相同，也可不同。

### 0x04 **大端小端表示\(测试\)**

1. **小端法：LSB排在最小的地址处（与习惯反着）**
2. **大端法：MSB排在最小的地址处（与习惯相同）**
3. **按字节存储，一字节是8位\(十六进制的2位\)**
4. **指令：操作码-&gt;寄存器编号-&gt;立即数。只有立即数考虑字节顺序。**

## 数值型数据表示与处理

### **0x01 整数\(定点数\)补码**

#### 1. 补码定义

　　假设补码有n位，则 $$[X]_补 = 2^n + X( -2^n\leq X < 2^n, mod 2^n)$$ X是真值， $$[X]_补$$ 是机器数。负权表示： $$X = -2^{w-1} + \sum_{i=0}^{w-2}x_i2^i$$ 

#### 2. 转化\(重点\)

1. 真值转补码：一个负数的补码等于对应正数补码按位取反、末位加1（简便方法：从右到左遇到第一个1前面各位取反）
2. 补码转真值：符号为0，则为正数，数值部分相同；符号为1，则为负数，数值各位取反，末位加1.

#### 3. 补码表示带符号数的优势\(重点\)

1. 补码运算是模运算系统，加、减统一
2. 数0的表示唯一，方便使用
3. 比原码或反码多表示一个最小负数

#### 4. 注意

1. 补码最小值不对称，n位机器码的最小负数 $$1 00..00 (n-1个0)$$ 
2. 运算器可看作模为 $$2^n$$ 的模运算系统

### 0x02 浮点数的编码表示

#### 1. IEEE754编码原理及过程，理解其引入非规格化数的原因

| type | S\(符号\) | exp\(阶码\) | frac\(尾数\) |
| :---: | :---: | :---: | :---: |
| float | 1bit | 8bits | 23bits |
| double | 1bit | 11bits | 52bits |

|  |  |
| :--- | :--- |
|  |  |



#### **2.** 真值和机器数之间的转换

* 真值转编码：将真值转为二进制科学计数法，填写**Sign**\(单1双1，正0负1\)，指数+Bias\(单127双1023\)填写**exp**\(单8双11\)，**frac**照搬小数部分\(单23双52，末尾补0\)
* 编码转真值：**sign**判断正负，**exp**-Bias得指数，**frac**根据exp转成二进制小数再转化\(frac转成十进制小数再乘以exp\)

#### 3. 给定格式浮点数表示的范围和精度

#### 4. float、double和int的精度比较

#### 5. 浮点数表示中谁决定了精度？谁决定了范围？

#### 6. 当数据是一个不可表示数时，机器会将其转换为最邻近的可表示数

#### 7. 解决C程序中与浮点数表示范围和精度相关的问题

#### 8. 上溢下溢：

　　当实数值超出浮点数能表示的最大范围，也就是发生上溢时，运行结果为无穷，下溢时，就近舍入0或者最小的非规格化数。NaN用于提示不合理操作

## 非数值型数据表示

## 整数的运算实现

### 0x01 移位

* 右移：**&gt;&gt;**，右移n位相当于除以 $$2^n$$ 
* 左移**：&lt;&lt;，**左移n位相当于乘以 $$2^n$$ 
* 无符号数：逻辑左移、逻辑右移
  *  逻辑左移：高位移出，低位补0，可能溢出；
  *  逻辑右移：低位移出，高位补0，可能产生有效数据丢失；
  *  溢出判断：若高位移出的是1，则左移时发生溢出
* 有符号整数：算术左移、算术右移
  *  算术左移：高位移出，低位补0，可能溢出
  *  算术右移：低位移出，高位补符，可能产生有效数据丢失；
  *  溢出判断：若移出的位不等于新的符号位，则溢出

### 0x02 位扩展和位截断

* 带符号数位扩展：前面补符号位 ，符号扩展
* 不带符号数扩展：前面补0 ，0扩展
* 与本身有关，与目标类型无关
* 高位截断

## 问题讨论

### 0x01 C程序中的整数

#### 1. 数据类型表示范围\(64位机器\)（重点）

| 类型名称 | 字节数 | 取值范围 |
| :---: | :---: | :---: |
| \(signed\) char | 1 | $$ -2^7(-128) $$ ~ $$2^7-1(127)$$  |
| usigned char | 1 | 0 ~ $$2^8-1(255)$$  |
| short \(int\) | 2 | $$-2^{15}(-32 768) $$ ~ $$2^{15}-1(32 767)$$  |
| usigned short | 2 | 0 ~ $$2^{16}-1(65 535)$$  |
| int | 4 | $$-2^{31}(-2 147 483 648)$$ ~ $$2^{31}-1(2 147 483 647)$$  |
| usigned （int\) | 4 | 0 ~ $$2^{32}-1(4 294 967 295)$$  |
| long int  | 4 | $$-2^{31}(-2 147 483 648)$$ ~ $$2^{31}-1(2 147 483 647)$$  |
| usigned long | 4 | 0 ~ $$2^{32}-1(4 294 967 295)$$  |
| long long | 8 | $$-2^{63}(-9.2233720368548e+18)$$ ~ $$2^{63}-1(9.2233720368548e+18)$$  |
| usigned long long | 8 | 0 ~ $$2^{64}-1(1.844674407371e+19)$$  |

#### 2. 编译器约定（重点）

1. 若表达式中同时有无符号和带符号整数，则C编译器将带符号整数强制转换为无符号数。
2. 处理常量时默认的类型
3. -x会看成x，然后取负运算

![&#x56FE;1 C&#x8BED;&#x8A00;&#x5904;&#x7406;&#x5E38;&#x91CF;&#x65F6;&#x9ED8;&#x8BA4;&#x7684;&#x7C7B;&#x578B;](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_17-25-12.jpg)

### 0x02 牛刀小试（重点）

![&#x56FE;2](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_17-40-25.jpg)

![&#x56FE;3](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_17-44-21.jpg)

![&#x56FE;4](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_11-45-49.jpg)

![&#x56FE;5](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_11-52-55.jpg)

![&#x56FE;6](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_18-01-37.jpg)

### 0x03 问题讨论1（重点）

![&#x56FE;7](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-17_11-58-58.jpg)

1. 不永真， $$0x0fffffff$$ ，使其溢出且最高位为1
2. 不永真， $$0x80000000$$ ，模拟钟表回拨
3. 永真；当x位于0x80000000~0xffffffff时，x&lt;0；当x位于0x00000000~0x7fffffff时，-x位于0x80000001~0x00000000，满足 -x ≤ 0；
4. 不永真：0x80000000

### 0x04 问题讨论2（重点）

![&#x56FE;8](https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/Snipaste_2020-03-18_07-54-57.jpg)

1. 当str1 &lt; str2时，size\_t是unsigned int 类型，strlen\(str1\) - strlen\(str2\)结果仍然是无符号类型，所以当str1 &lt; str2时，差还大于0.
2. `return strlen(str1) >  strlen(str2)`

### 0x05 无符号数

* **问**：你觉得计算机中为什么要支持无符号数呢？只用带符号整数可以吗？因为无符号数和带符号整数对数据表示的差异性，所以经常会导致数据转换时出现错误。你觉得在使用无符号数时，应避免踩哪些坑呢？也可以说说你的疑问。
* 1. 扩大数据表示范围，因为在无符号数中，所有的位都用于直接表示该值的大小。
  2. 原则上可以，但是如果要表示的数据都是非负数，这时使用带符号数会造成符号位的浪费\(因为符号位只为0\)；
  3. 使用无符号数时应该避免与带符号数的直接运算。

### 0x06 偏置常数

* **问**：偏置常数的作用是什么？IEEE754为什么把偏置常数设为2的n-1次方-1？（n是阶码位数）如果设成2的n-1次方会怎样？
* 1. Bias作用：将浮点数的指数统一转换为正指数，避免正负指数在计算上带来的麻烦；
  2. 扩大浮点数取值范围。精度越大则取值范围越小，精度越小则取值范围越大。以32位单精度浮点数为例：用127，阶码的范围是0000 0001（-126）~1111 1110（127）；用128，阶码的范围会变成0000 0001 （-127）~1111 1110（126）；显然如果使用128作为偏置常数，能表示的最大的指数是126，使用127作为偏置常数，能表示的最大的指数是127。所以规定8位阶码的Bias为127，使得浮点数的取值范围更大。

### 0x07 位扩展

* **问：**不同长度的数据类型在进行算术运算的时候，要对短数据进行位扩展，为什么不能直接运算呢？这里，位扩展的作用是什么呢？能举出实例来说明吗？
* 1. 原因：直接运算可能出现符号位错位而导致运算异常的情况
  2. 作用：将数据转化为同一类型，以便“正确”运算
  3. 举例：short 类型的6\(0x0006\)经位扩展转为int类型的6\(0x0000 0006\)

### 0x08 浮点数的阶码可以用补码编码吗？

* **问**：阶码可以用补码编码吗？既然移码是为了避免负阶而加的偏置常数，那为什么不直接用补码来表示阶呢？虽然有正负阶，但是我们补码一样可以方便地进行加减乘除运算啊，为什么用移码而不用补码呢？
* 1. 补码属于无符号数原码，利于比较大小；
  2. 便于判断规格化的值、非规格化的值、特殊值；
  3. 移码可使非规格化值平滑转换到规格化值。

### 0x09 位扩展程序

```c
#include<stdio.h>
int main()
{
	unsigned int a = 1;
	unsigned short b = 1;
	char c = -1;//补码全1
	int d; 
	d = (a > c) ? 1:0;
	printf("%d\n", d); 
	d = (b > c) ? 1:0;//short与char转成int
	printf("%d\n", d);
	return 0;
}
```

* **位扩展**：**char&short --&gt; int --&gt; usigned --&gt; long\(?\) --&gt;double &lt;-- float**
* char，unsigned short类型都是转成int来比较 c: 0xffff ffff b: 0x0000 0001 这是两个int比较，c=-1, b=1

### 0x0a char is signed or unsigned?

 　　C标准规定为 Implementation Defined（由**实作环境**决定\)。例如：arm-linux-gcc 规定 char 为 unsigned char，vc 编译器、x86上的 gcc 规定 char 为 signed char。缺省情况下，编译器默认数据为signed类型，但是char类型除外。  
　　这样会带来一些麻烦：代码移植\(使用char的时候，前面最好加个unsigned或signed\)；做位扩展题的时候到底是看作带符号数还是不带符号数\(我用电脑和朋友用手机运行我们这节课的讨论题就出现两个结果\)？  
　　输出CHAR\_MIN \(在limits.h头文件中\)的值就知道自己环境默认的是有符号还是无符号。

