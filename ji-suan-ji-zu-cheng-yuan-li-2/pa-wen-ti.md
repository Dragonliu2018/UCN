# PA问题

## PA0

### 0x01 Linux and Linux?

* 相同点：四者都是Linux的发行版本，都使用Linux内核；
* 不同点：**从发行系列角度**，Debian和Ubuntu属于一个系列， CentOS和Red Hat属于一个系列；**从性质角度**，linux大体分为由商业公司维护的商业版本与由开源社区维护的免费发行版本，商业版本以Redhat为代表，开源社区版本则以Debian为代表；**从用户或者用途角度**， CentOS 、Red Hat 、Debian通常用于服务器领域，内核版本通常使用Linux2.6版本，运行十分稳定，而Ubuntu通常用于桌面领域，内核版本通常比较新，一般跟Linux内核同步更新；**从安装包管理方式角度**， CentOS和Red Hat使用yum/rpm进行安装包管理，Debian和Ubuntu 使用apt/dpkg的管理方式，但使用配置上大同小异。

### 0x02 Can't memory be larger?

问题1：内存大小不能无限大，一方面32位系统最大只能支持4GB内存，另一方面取决于物理机内存。

问题2： CPU不能直接访问硬盘的数据，只能通过把硬盘的数据先放到内存里， 然后再从内存里访问硬盘的数据。计算机操作系统会给内存每1个字节分配1个内存地址，在32位操作系统中, 内存的地址就是32位的2进制数，所以32位的地址范围是0x00000000 ~ 0xFFFFFFFF。地址个数：2^32 = 4 \* 1024\(G\) \* 1024\(M\) \* 1024\(K\) = 4294967296 ,而每1个地址对应1个1个字节， 容量就是1byte， 所以2^32个地址就总共能对应应**4GB** 的内存容量。简言之，CPU寻址范围决定最大支持内存。

### 0x03 Why Windows is quite 'fat'?

　　Windows有GUI，而我们安装的Debian是CLI，没有图形化界面，所以安装Windows需要更多的磁盘空间和内存，因此Debian非常‘slim’，Windows相当'fat'。

### 0x04 Why executing the 'poweroff' command requires superuser privilege?

　　当Linux被用作服务器或类似服务器时，很多用户通过SSH进入Linux机器，其中一个具有SSH访问权限的人将其关闭，其他远程登录的用户也被迫关机，如果其他用户在做十分重要的事情，那么损失很大，此外，远程登录的用户将无法重新打开它。

### 0x05 What happened?

 　　`make`命令执行后，读入所有的Makefile，目标文件与所有的`.c`文件创建依赖关系，目标文件生成，对应的整个项目被编译。

### 0x06 How will you do?

 　　最重要的是设计好CPU，编写程序，使控制器能够控制运算器进行数据加工、从内存取送数据；存储器能够保存信息；然后再编写驱动程序能够驱动I/O等外部设备。

## PA1.1

### 1. 存放的是什么？

　　PC存放指令的存放地址而不是指令本身。因为除了程序计数器PC外还有个指令寄存器IR，IR是存放当前执行指令的，PC指向下条执行指令地址，用地址取指的方式便于执行跳转指令。

### 2. 贵圈真乱

```text
 +---------------------------------+
 |      "Hello World" program      |
 +---------------------------------+
 |      Abstract Machine(AM)       |
 +---------------------------------+
 |      Simulated x86 Hardware     |
 +---------------------------------+
 |              NEMU               |
 +---------------------------------+
 |            GNU/Linux            |
 +---------------------------------+
 | VirtualBox (Simulated Hardware) |
 +---------------------------------+
 |      Host Operating System      |
 +---------------------------------+
 |        Computer hardware        |
 +---------------------------------+
```

### 3. 虚拟机和模拟器的区别

* **模拟方面**：模拟器可以模拟不同指令集、不同体系架构的 CPU，如ARM, PowerPC, MIPS, x86等；而虚拟机基本都是去模拟一套相同指令集相同架构的硬件平台
* **速度方面**：虚拟机很多时候可以直接利用 CPU 去执行目标指令。虽然还是模拟物理 CPU 而不借助于 Host OS 的功能，毕竟少了一层指令集转换，与模拟器相比，运行速度会提高不少。

### 4. 从哪开始阅读代码呢

主函数\(main.c\)

### 5. 究竟要执行多久

　　传入参数-1 是满足CPU 的工作方式：不断执行指令。原因：-1的补码是全1\(32个1\)，而cup\_exec\(\)的传参类型是uint64\_t\(unsigned long long\)，数据类型转换为uint64类型的最大值\(64个1\)，所以该函数中的for循环执行次，也就是函数exec\_wrapper\(\)执行次。我们的计算机每秒执行次数在量级，所以模拟CPU的工作时间在\(s\)量级，虽然不是无穷，但已足够满足CPU的工作方式要求。

### 6. 谁来指示程序的结束?

　　main结束不代表整个进程结束，比如全局对象的析构函数会在main函数之后执行；用atexit注册的函数也会在main之后执行。很多时候我们需要在程序退出的时候做一些诸如释放资源的操作，方法就是用atexit\(\)函数来注册程序正常终止时要被调用的函数，使得他们在main结束以后被调用。

### 7. 为什么会这样？

　　数据的存储方式使用了小端模式，数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，所以输出顺序会不一样。

## PA1.2&1.3

### 1. 有什么办法?

* **问**：表达式求值有许多方法，你能想到比较常见的哪些方法呢？在这里你可以尽情发挥自己的想象，充分运用已经学过的知识，也可以通过查阅相关资料来简单描述一下你的想法。
* **答**：利用栈解决表达式求值问题，输入一个中缀表达式，具体算法如下：
  1. 设立操作数栈与运算符栈；
  2. 设表达式的结束符为“\#”，预设运算符栈的栈底为“\#”；
  3. 若当前字符是操作数，则直接压入操作符栈 ；
  4. 若当前字符是运算符，且运算符的优先级高于栈顶运算符则进栈；否则，从操作数栈中弹出两个操 作数并弹出运算符栈的栈顶运算符，经计算后将结果压入操作数栈。

### 2. 一些简单的正则表达式

* 以 `0x` 开头的 `32` 位十六进制整数： **0x\[a-f0-9A-F\]{32}** \(以`0x`开头，`[a-f0-9A-F]{32}`表示由a-f、A-F、0-9其中任意32个字符组成\)
* 英文字母和数字组成的字符串：**\[a-z0-9A-Z\]+** \(匹配到1~n个字母或数字\)
* C 语言中的变量名或函数名：**\[a-zA-Z\_\]{1}\w\*** \(`[a-zA-Z_]{1}`匹配第一个字符为字母或下划线，`\w*` 表示其后有0~n个字母或数字或下划线组成，但此处同样会匹配到关键字\)
* 学号 - 姓名 - PA1.1.pdf，如 `161722222 - 张三 - PA1.1.pdf`：**\d{9}\s-\s\[\u4e00-\u9fa5\]+\s-\sPA\d.\d.pdf** \(`\d{9}`以9位数字的学号开头，`\s-\s`表示空格-空格，`[\u4e00-\u9fa5]+`匹配到一个及以上的汉字，`PA\d.\d.pdf`表示文件命名格式\)

### 3. 这是为什么?

* **问**：如果你需要使用正则表达式中的转义字符 `\`，你应该在定义规则的字符串中输入两个 `\` 才能代表一个 `\`，想一想，这是为什么？
* **答**：`\`是特殊字符，作用是将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符，所以输入两个 `\` 才能代表一个 `\`。

### 4. 如何处理以上的问题

在make\_tokens\(\)里，匹配到的字符串分为操作符，16进制数，10进制数，和寄存器名称四类

* 操作符，直接存储类型
* 16进制数，`0x...`，记录类型和字串
* 寄存器名称，`$xxx`，记录类型和字串
* 10进制，输入长度不能确定，可能会超过32；但是，32位系统中，能表示的最大整数为4294967295，长度小于32,即正常情况下不会溢出。
* `str`成员的长度是有限的\(32位\), 缓冲区溢出则停止程序\(assert\(0\)\)即可。

### 5. 递归求值的过程?

```text
 //表示方式1
 expr->expr+term|expr-term|term
 term->term x factor|term|factor|factor
 factor->digit|(expr)
 ​
 //表示方式2
 E → T { +T | -T }
 T → F { *F | /F }
 F → (E) | d
```

上述BNF范式，一个表达式就是一个由+或-分割开来的项（term）列表，而项是由x或者\|分隔的因子（factor）列表。参考：[https://www.cnblogs.com/OceanEyes/p/implement\_a\_interpreter.html](https://www.cnblogs.com/OceanEyes/p/implement_a_interpreter.html)

### 6. 体验监视点

1. `l`：查看程序
2. `b main`：设置断点
3. `r`：运行程序
4. `watch num == 1 watch cnt == 1`：添加监视点
5. `info watch`：显示当前所有监视点的列表
6. `c [Enter]`：运行程序，监视点命中
7. `d 3`：删除编号为 3 的监视点，`info watch`进行检查
8. `r`：重新运行程序，程序不能在被删除的监视点上命中

### 7. 科学起名

* **问**：上述的池管理中，对于空闲监视点的管理，使用 `free_` 作为头指针，那此处可否使用 `free` 来作为头指针的名字呢？如果使用 `free` 作为头指针名，从语法上看起来好像没错，但是到编译运行的时候，还能一帆风顺吗？\(hint: 符号名撞车\)
* **答**：不能使用`free`作为头指针的名字，C语言变量命名规则中禁止使用关键字，`free`是关键字\(**free\(\)函数**\)，编译运行是会报错。

### 8. 温故而知新

* **问**：框架代码中定义 `wp_pool` 等变量的时候使用了关键字 `static`，`static` 在此处的含义是什么？为什么要在此处使用它？
* **答**：全局变量`wp_pool`的说明之前冠以`static` 就构成了静态的全局变量；非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

### 9. 一点也不能长?

* **问**：我们知道 `int3` 指令不带任何操作数，操作码为 1 个字节，因此指令的长度是 1 个字节。这是必须的吗？假设有一种 x86 体系结构的变种 my-x86，除了 `int3` 指令的长度变成了 2 个字节之外，其余指令和 x86 相同。在 my-x86 中，文章中的断点机制还可以正常工作吗？为什么？
* **答**：必须的；不能，因为 int3 指令长度为1个字节时，且在目标断点指令的第一个字节处，当程序执行到0xcc，就会触发异常，进入调试。 但当我们把int3指令的长度换为2个字节后，会遇到如下问题：
  1. 允许插入一个断点时覆盖到的指令不会多于一条，因为x86架构上指令最短的长度就是1字节，这样我们可以保证只有我们希望停止的那条指令被修改；
  2. 遇到单字节指令，2位长度的 int3 会影响到其他指令；
  3. 在运行过程中，按每个字节的内容来解读，改变后的int3指令就会被分开，可能不会正确解读。

### 10. “随心所欲”的断点

* **问**：如果把断点设置在指令的非首字节（中间或末尾），会发生什么？你可以在 GDB 中尝试一下，然后思考并解释其中的缘由。
* **答**：发现出现了段错误。 若断点设在非首字节，则会改变断点所在指令内容,断点之前的指令应该会正常执行，而该执行断点所在指令时，可能不存在相应的指令，就发生段错误。也有可能因为执行了未知的命令。同时，由于中断指令修改的不是指令开头，并不会执行中断指令，也就不会打印触发断点的信息。

### 11. NEMU 的前世今生

* **问**：你已经对 NEMU 的工作方式有所了解了。事实上在 NEMU 诞生之前，NEMU 曾经有一段时间并不叫 NEMU，而是叫 NDB\(NJU Debugger\)，后来由于某种原因才改名为 NEMU。如果你想知道这一段史前的秘密，你首先需要了解这样一个问题：模拟器 \(Emulator\) 和调试器 \(Debugger\) 有什么不同？更具体地，和 NEMU 相比，GDB 到底是如何调试程序的？
* **答**：
  * 仿真器（emulator）的目的是作为目标系统的替代品，可以完全替代目标系统，完成其对外的功能，即仿真器系统只需要保证呈现给外部的行为跟目标系统一致（不需要保证内部运行原理一致）。例如想在电脑上玩小时候玩的街机游戏，就需要在电脑上安装一个街机仿真器（虽然很多人喜欢称其为“街机模拟器”）。使用仿真器的目的是模拟目标系统呈现出的运行环境，仿真器保证的是完成目标系统相同的行为，不在乎其内部实现原理，再例如EMU8086仿真器，可以在另一台非8086电脑上仿真8086微处理器的行为。即使再好的仿真器也不能作为模拟器用于研究目标系统内部运行原理。
  * 调试器的工作原理是基于[中央处理器](https://baike.baidu.com/item/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8)的异常机制，并由操作系统的异常分发\事件分发的子系统（或模块）负责将其封装处理后，以比较友好的方式与调试器进行实时交互。每当调试器捕获到一个异常\事件之后，将会根据调试器的自身逻辑来判定是否需要接管这个异常\事件，并决定由调试器的哪个函数来接管。当调试器接管下来这个异常\事件后，将根据用户的需求对其进行进一步的处理，处理完毕后再通知系统已经处理完毕，此时新一轮的异常\事件捕获、分发循环开始。
* **参考**：
  * [仿真器和模拟器的区别](https://blog.csdn.net/qianlong4526888/article/details/58258749)
  * [百度百科--调试器]([https://baike.baidu.com/item/%E8%B0%83%E8%AF%95%E5%99%A8]%28https://baike.baidu.com/item/调试器%29)

### 12. 尝试通过目录定位关注的问题（5分）

* **问**：假设你现在需要了解一个叫`selector`的概念, 请通过i386手册的目录确定你需要阅读手册中的哪些地方.
* **答**：通过`Foxit`打开i386手册，在左侧目录寻找`selector`，最终定位到：**Chapter 5 Memory Management** --&gt; **5.1 Segment Translation** ---&gt; **5.1.3 Selectors**，之后通过阅读验证，是否为要查找的内容。

### 13. 理解基础设施（5分）

* **问**：我们通过一些简单的计算来体会简易调试器的作用. 首先作以下假设:

  * 假设你需要编译500次NEMU才能完成PA.
  * 假设这500次编译当中, 有90%的次数是用于调试.
  * 假设你没有实现简易调试器, 只能通过GDB对运行在NEMU上的客户程序进行调试. 在每一次调试中, 由于GDB不能直接观测客户程序, 你需要花费30秒的时间来从GDB中获取并分析一个信息.
  * 假设你需要获取并分析20个信息才能排除一个bug.

  那么这个学期下来, 你将会在调试上花费多少时间?

  由于简易调试器可以直接观测客户程序, 假设通过简易调试器只需要花费10秒的时间从中获取并分析相同的信息. 那么这个学期下来, 简易调试器可以帮助你节省多少调试的时间?

  事实上, 这些数字也许还是有点乐观, 例如就算使用GDB来直接调客户程序, 这些数字假设你能通过10分钟的时间排除一个bug. 如果实际上你需要在调试过程中获取并分析更多的信息, 简易调试器这一基础设施能带来的好处就更大.

* **答**：
  1. 调试时间\(使用GDB\)：**30 \* 20 \* 500\* 90% = 2.7e5 s = 75 h**
  2. 调试时间\(简易调试器\)：**10 \* 20 \* 500\* 90% = 9e4 s = 25 h**
  3. 节省时间：75 - 25 = 50h，节省三分之二的时间。

### 14. 查阅i386手册（5分）

* **问**：理解了科学查阅手册的方法之后, 请你尝试在i386手册中查阅以下问题所在的位置, 把需要阅读的范围写到你的实验报告里面:
* EFLAGS寄存器中的CF位是什么意思?
  * ModR/M字节是什么?
  * mov指令的具体格式是怎么样的?
* **答**：
  * `ctrl + f`定位**3.2.1 Subtraction Instructions** ，原文：`CF is set if a one-bit was carried out of the high-order position (addition instructions ADD, ADC, AAA, and DAA) or if a one-bit was carried (i.e.borrowed) into the high-order bit (subtraction instructions SUB, SBB, AAS,DAS, CMP, and NEG)` 所以：EFLAGS寄存器中的CF位是进位借位标志位的意思，用于表示无符号数加减运算时的进/借位。
* `ctrl + f`定位**2.5.3 Memory Operands**
  * 通过目录确定为345页

### 15. shell命令（5分）

* **问**：完成PA1的内容之后, `nemu/`目录下的所有.c和.h和文件总共有多少行代码?
* **答**：4232
* **问**：你是使用什么命令得到这个结果的?
* **答**：`find -name "*[.h|.c]" -type f | xargs cat | wc -l`
* **问**：和框架代码相比, 你在PA1中编写了多少行代码? \(Hint: 目前`master`分支中记录的正好是做PA1之前的状态, 思考一下应该如何回到"过去"?\)
* **答**：`git checkout master`切换到master分支，执行上述命令得`3536`，做差得在PA1中编写了696行代码。
* **问**：你可以把这条命令写入`Makefile`中, 随着实验进度的推进, 你可以很方便地统计工程的代码行数, 例如敲入`make count`就会自动运行统计代码行数的命令.
* **答**：在`Makefile`中添加：

  ```text
    count:
    find -name "*[.h|.c]" -type f | xargs cat | wc -l
  ```

  效果： ![](file://H:/PA_work/%E8%AF%BE%E8%AE%BE/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/PA1.2&1.3/img/Snipaste_2020-04-18_09-49-16.jpg?lastModify=1591368450)

* **问**：再来个难一点的, 除去空行之外, `nemu/`目录下的所有`.c`和`.h`文件总共有多少行代码?
* **答**：使用命令：`find . -name "*[.h|.c]"|xargs cat|grep -v ^$|wc -l`得`3542`\(PA1\)，`2859`\(master\)

### 16. 使用 man （5分）

* **问**：打开工程目录下的`Makefile`文件, 你会在`CFLAGS`变量中看到gcc的一些编译选项. 请解释gcc中的`-Wall`和`-Werror`有什么作用? 为什么要使用`-Wall`和`-Werror`?
* **答**：
  * `-Wall`，打开gcc的所有警告
* `-Werror`，它要求gcc将所有的警告当成错误进行处理
  * 在Makefile编译中,如果加上-Wall -Werror，则可以防止函数定义未使用、定义未使用等情况的报错，保证了程序的正确运行；还可以将程序中所有的warning都指示成为error，防止程序因为warning造成程序的不稳定性。一种`宽容`一种`苛刻`，适应不同的开发情景。

